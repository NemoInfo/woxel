%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\section{Ray tracing}
With the structure of the rendering engine and the primary data structure covered, it is time to bring everything together to construct an image.
A ray tracing algorithm is required, first needing an algorithm to cast a ray.
This section will cover methods for casting rays and ray-tracing algorithms, as well as how these integrate with the VDB data structure to optimise performance.

\subsection{Casting a ray}
The background section glossed over a suite of ray-casting algorithms.
This section will detail the implementation of three such algorithms, all built on top of each other: DDA, HDDA, and HDDA+SDF.

\subsubsection{DDA}
\acrshort{dda} works by ray marching from grid intersection to grid intersection, ensuring each voxel is only polled once.
The starting values are a source point and a normalised direction vector.
\begin{enumerate}
  \item Initial Position (ipos): The starting position of the ray within the voxel grid, calculated by flooring the source vector. It gives the indices of the voxel grid where the ray starts.
  \item Delta Distance (deltaDist): This calculates how far the ray must travel in each axis to cross a voxel boundary. It is computed by dividing the length of the direction vector (dir) by each component of the direction vector, giving the distance the ray travels in each axis per step.
  \item Step (step): A vector determining the direction to step through the grid in each axis (i.e., whether to increment or decrement the index in each dimension). It is determined by the sign of the direction vector components.
  \item Side Distance (sideDist): This vector stores the distance the ray needs to travel to hit the next side of a voxel. It starts with the distance to the first boundary from the source position, adjusted by half a voxel size in the direction of travel to ensure the calculation centres within a voxel.
\end{enumerate}

The core idea of the algorithm is that it precomputes the amount one unit of movement on either axis causes the ray to progress (\texttt{deltaDist}). It then maintains a record of how far the ray has progressed on each axis and selects the one for which the ray has moved the least, i.e. the closest boundary intersection.

\begin{lstlisting}[language=rust, captionpos=b, caption={\texttt{DDA} algorithm}]
const MAX_RAY_STEPS: i32 = 64;
fn cast_ray_dda(src: vec3<f32>, dir: vec3<f32>) -> vec3<f32> {
  var ipos = vec3<i32>(floor(src));
  let deltaDist = abs(vec3<f32>(length(dir)) / dir);
  let step = vec3<i32>(sign(dir));
  var sideDist = (sign(dir) * (vec3<f32>(ipos) - src) + (sign(dir) * 0.5) + 0.5)
    * deltaDist;
  var mask = vec3<bool>(false);

  for (var i: i32 = 0; i < MAX_RAY_STEPS; i++) {
    let val = getVoxel(ipos);
    if (val.hit) {
      return val.color + dot(vec3<f32>(mask) * vec3(0.01, 0.02, 0.03), vec3(1.0));
    }

    var b1 = sideDist.xyz <= sideDist.yzx;
    var b2 = sideDist.xyz <= sideDist.zxy;
    mask = b1 & b2;

    sideDist += vec3<f32>(mask) * deltaDist;
    ipos += vec3<i32>(mask) * step;
  }

  return vec3<f32>(dir);
}
\end{lstlisting}

Specifically, at each iteration of the ray marching loop, three operations are performed:
\begin{enumerate}
  \item Voxel Check: At each step, the algorithm checks whether the current voxel (ipos) is occupied by using the getVoxel(ipos) function. If this function returns true, indicating a hit, the loop exits as the ray has intersected a voxel, and its colour, adjusted to distinguish between the face on which the ray hit, is returned.
  \item Boundary Calculation: Determines which voxel boundary (x, y, or z) will be hit next by comparing the distances in sideDist. The logic here involves comparing each component of sideDist against the others to find the smallest value. This is computed using vector comparisons b1 and b2, which are boolean vectors.
  \item Update sideDist and ipos: Updates the current side distance and position based on which boundary will be hit next. For example, If the smallest distance is in the x-direction, then the x-component of sideDist and ipos are updated.
\end{enumerate}

\subsubsection{HDDA}
This section covers the Hierarchical DDA specifically tailored for traversing volumetric data represented in a VDB, using the data structure at last. This method is much more effective in handling large and sparse volumetric datasets due to its hierarchical traversal mechanism, which significantly enhances computational efficiency and scalability.

The key idea is to scale the ray step at each iteration by the lowest level of detail at that point. For example, at a point in an empty Node4, there is no reason not to step directly the side length of a Node4 along an axis since it is guaranteed that there is no voxel data in that node.

The following is a breakdown of the algorithm in \cref{hdda:code}:
\paragraph{Initialisation}
\begin{enumerate}
  \item The ray's initial position \texttt{p} is set to the source point src.
  \item The \texttt{step} vector determines the traversal direction in the grid is the non-zero sign of the ray.
  \item The \texttt{step01} vector is used as a flag to determine whether the size on a given axis should be added when calculating step candidates.
        It essentially discriminates between the cases shown in \cref{hdda:fig}.
  \item The \texttt{idir} vector represents the inverse of the directional vector.
        \newacronym{fpu}{FPU}{Floating-Point Unit, a coprocessor for handling floating point numbers}
        It is precomputed to avoid doing element-wise division in the loop's body since multiplication is faster than division on \acrshort{fpu}s.
  \item The \texttt{mask} has the same role as in standard DDA; it will be used to decide which increment produced the smallest step on the ray.
\end{enumerate}
With this initial information, the ray can start marching along the VDB.

\begin{figure}[H]
  \centering
  \includesvg[width=0.6\linewidth]{hdda}
  \caption[HDDA iteration diagram]{
    \texttt{HDDA} iteration. (a): Ray positive on both axes.
    When a ray direction has a positive component, because of the directionality of the modulo operation, it must be subtracted from the size of the node to maintain the ray direction.
    (b): Ray negative on both axes. When a ray has a negative component, the modulo must simply be inverted since the size is already accounted for. \\
    Blue and grey vectors are candidate steps at the given iteration; each has its components outside the squares.
    The blue vector has to be selected since it is the shorter one.
    The black vector represents the modulo-size vector. The $\odot$ operation denotes element-wise multiplication.
    A small branching factor is not typical of the VDB data structure; this was chosen purely for visual clarity.
  }
  \label{hdda:fig}
\end{figure}

\textbf{Loop} \\
The ray traversal loop has the following steps:
\begin{enumerate}
  \item \textbf{Qeuery the VDB} for the value at the current position. If the value is non-empty or out of bounds, return a colour for the voxel
  \item\label{ray:enum1} \textbf{Compute step calculations} scaled by the size of the current level.
        Compute the candidate steps in all three axes, choose the minimum and step the ray in that direction
  \item \textbf{Adjust the position} by a tiny factor to ensure it will query the next cell.
        Since the algorithm deals with points on edges, sampling a point directly on edge is prone to floating point issues,
        so the position is nudged by a small amount towards the cell in the direction selected at \cref{ray:enum1}.
\end{enumerate}

\begin{lstlisting}[language=rust, captionpos=b, caption={\texttt{HDDA} algorithm}, label={hdda:code}]
const HDDA_MAX_RAY_STEPS: u32 = 1000u;
const scale = array<f32, 4>(1., 8., 128., 4096.);
fn hdda_ray(src: vec3<f32>, dir: vec3<f32>) -> vec3<f32> {
  var p: vec3<f32> = src;
  let step: vec3<f32> = sign11(dir);
  let step01: vec3<f32> = max(vec3(0.), step);
  let idir: vec3<f32> = 1. / dir;
  var mask = vec3<bool>();
  var bottom: VdbBottom;

  for(var i: u32 = 0u; i < HDDA_MAX_RAY_STEPS; i++){
    bottom = get_vdb_bot_from_bot(vec3<i32>(floor(p)), bot);

    if !bottom.empty {
      // return voxel color
    }
    if any(p < min_bound || p > max_bound) {
      // return bounding box color
    }
    let size: f32 = scale[3u - bot.num_parents];
    let tMax: vec3<f32> = idir * (size * step01 - modulo_vec3f(p, size));

    p += min(min(tMax.x, tMax.y), tMax.z) * dir;

    let b1 = tMax.xyz <= tMax.yzx;
    let b2 = tMax.xyz <= tMax.zxy;
    mask = b1 & b2;

    p += 4e-4 * step * vec3<f32>(mask);
  }
  // return maximum steps exceeded color
}
\end{lstlisting}

\paragraph{Using the VDB}
At this point, we can finally make use of the topology of the VDB data structure.
The size of the step in HDDA is determined by the lowest node level at that point.
This can be computed by stepping down the tree until we get either a voxel value or a node's tile value (a value is also meant to mean empty here).
This works fine, but there is some potential for further optimisation.

HDDA usually steps through neighbouring cells, and these neighbouring cells have the same parent (except for cells at the border of the parent's 3D grid).
When a ray passes through a Node3, which represents $8\times8\times8$ voxels, assuming no collision, eight voxel checks are expected, at minimum (when the ray passes parallel to either axis).
For each of these eight checks, the lookup in the VDB structure would consist of going from the root node to a Node5 to a Node4, then to a Node3, and then indexing into its grid.
However, if the algorithm would remember the chain of nodes from the previous iteration, it could simply check if the voxel it needs is in the Node3 it already has, and use that, if not go up to the parent and check again. These cases are the majority of cases. For eight voxels in a horizontal line, 7 out of 8 would be in this case,
all but the first, which would have to go up to the Node4 to get the neighbouring Node3 and then index the voxel.
This method optimises lookups for virtually no cost, just using the data structure's topology. This idea would not work in an octree, for example, because in an octree, all nodes are boundary nodes.
This is where the grid-like properties of the VDB shine.

In the software implementation, the structure \texttt{VdbBottom} (\cref{hdda:bot}) is constructed, meant to represent the path to the bottom of a query in VDB.
Along with this data structure, the method \linebreak \texttt{get\_vdb\_bot\_from\_bot} (used in \cref{hdda:code}) is created.
The method does exactly what was described above: it tries to get the next value using the nodes of the previous one from the bottom up.

\begin{lstlisting}[language=rust, captionpos=b, caption={
    \texttt{VdbBottom} defintion.
    The structure holds the three (or fewer) parents that the bottom value has, whether the bottom was an empty value, and the colour information if it was voxel.
  }, label={hdda:bot}]
struct Parent {
    origin: vec3<i32>,
    idx: u32,
}

struct VdbBottom {
    color: vec3<f32>,
    empty: bool,
    num_parents: u32,
    parents: array<Parent, 3>,
}
\end{lstlisting}

This HDDA algorithm is already highly efficient (see \cref{table:2}) and can render complex scenes with high voxel counts and dynamic lighting very well. However, it is always possible to do better.

\subsubsection{HDDA+SDF}
This section shows the final improvement to the ray casting algorithm.
It combines the HDDA algorithm described in the last part with the \acrshort{sdf} data described in \cref{vdb:sdf}.
The idea is simple: at each level of the hierarchy, instead of stepping by one unit in relative space, step by as many as the SDF allows.
With the SDF already computed, modifying the HDDA algorithm is as simple as changing a few lines of code and multiplying the step size by the minimum distance.

\begin{lstlisting}[language=rust, caption={HDDA+SDF tweaks}, captionpos=b]
fn hdda(src: vec3<f32>, dir: vec3<f32>) -> vec3<f32> {
  ...
      let size: f32 = scale[3u - bot.num_parents] * bot.dist;
  ...
}
struct VdbBottom {
  ...
  dist: u32, // empty becomes dist
}
\end{lstlisting}

The simple HDDA algorithm would have satisfied the goals and objectives set for this project, but this version is even better. At this point, it is time to test these algorithms by adding lights and reflections.

\subsection{Sunlight}
Sunlight can be described by direction and colour. The idea is to cast camera rays through the scene, and when a ray intersects an object, another ray is cast from that point in the direction of the sun.
If that ray intersects anything else, the object is in shadow, so sunlight does not contribute to its colour; otherwise, sunlight hits an object and, therefore, contributes to its colour.

An important part of this algorithm is calculating the contribution of sunlight to an object's colour.
A straightforward way would be to add the sunlight colour to the colour of the object times some intensity coefficient.
However, the angle at wich the sunlight hits a voxel face is a key aspect of this calculation. The dot product of the sunlight direction and the surface normal of the object can be used to determine how much sunlight falls on the face of an object.

The following model based on the Lambertian Reflectance Formula\supercite{light} is proposed:
\begin{align*}
\intertext{\textbf{Ambient Lighting} represents indirect light scattered in the environment and illuminates all objects equally.}
  \vec I_{ambient} &= k_{a} \cdot C_{ambient} \odot \vec C_{surface}
\intertext{\textbf{Diffuse Lighting} represents the light from the sun and affects surfaces based on their orientation relative to the light source.}
  \vec I_{diffuse} &= k_{d} \cdot (\vec L \cdot \vec N) \cdot \vec C_{sunlight} \odot \vec C_{surface}
\intertext{When an object is \textbf{in shadow} it does not receive sunlight, so the $I_{diffuse}$ component is ommited}
  \vec C_{total} &= \vec I_{ambient} \\
  \vec C_{total} &= k_{a} \cdot C_{ambient} \odot \vec C_{surface}
\intertext{When an object is \textbf{not in shadow} $I_{diffuse}$ is added to the ambient color}
  \vec C_{total} &= \vec I_{ambient} + I_{diffuse} \\
  \vec C_{total} &= k_{a} \cdot C_{ambient} \odot \vec C_{surface} + k_{d} \cdot (\vec L \cdot \vec N) \cdot \vec C_{sunlight} \odot \vec C_{surface}
\intertext{Where:}
  k_{a} &= \text{ambient reflectance coeffcient} \\
  k_{d} &= \text{diffuse reflectance coeffcient} \\
  \vec L &= \text{normalized direction vector from the surface to the light source} \\
  \vec N &= \text{normalized surface normal} \\
  \vec C_{surface} &= \text{color of the surface} \\
  \vec C_{ambient} &= \text{ambient color} \\
  \vec C_{snlight} &= \text{sunlight color}
\end{align*}

This model has a straightforward software implementation. The function \texttt{hdda\_ray} now returns a custom output type that carries information
about the result of the ray cast operation, such as state (hit, miss or out of steps), the render mode, which will be shown in the experiments section \cref{rendermods},
the HDDA mask used to determine the surface normal of the intersected voxel, and the point of intersection.
The only difference from the mathematical model above is that the alpha channel of the sun's colour is used to encode sunlight strength.

\begin{lstlisting}[language=rust,caption={Sunlight rendering on diffuse materials}, captionpos=b]
fn ray_trace(src: vec3<f32>, dir: vec3<f32>) -> vec3<f32> {
  let hit: HDDAout = hdda_ray(src, dir);
  let step: vec3<f32> = sign11(dir);
  ...
  if hit.state == 0u {
    switch hit.render_mode {
    ...
    case 3u: {
      let N = normalize(-step * vec3<f32>(hit.mask));
      let LN = max(0.0, s.sun_color.a * dot(-s.sun_dir, N));
      let I_d = k_d * s.sun_color.xyz * hit.color * LN;
      let I_a = k_a * AMBIENT_COLOR * hit.color;

      if LN != 0.0  &&
      hdda_ray(hit.p - 4e-2 * step * vec3<f32>(hit.mask), -s.sun_dir).state == 0u {
        return I_a;
      }

      return I_a + I_d;
    }
  }
  ...
}
\end{lstlisting}

\subsection{Glossy Materials}
Adding glossy materials requires bouncing the rays off objects recursively. Unlike perfectly diffuse surfaces that scatter light in all directions, glossy surfaces cause more directed reflections, often leading to visible specular highlights and clear reflections of the environment.

A more complex approach to ray tracing is required, a method that includes handling recursive ray bounces to accurately simulate the reflection phenomena.
For glossy materials, when a ray intersects the surface, it typically generates at least two additional types of rays:
\begin{enumerate}
  \item \textbf{Shadow Ray:} This ray is cast towards light sources shown in the previous section.
  \item \textbf{Reflected Ray:} This ray simulates the reflection of light off the surface, calculated based on the angle of incidence and the normal at the point of intersection.
        The direction of the reflected ray is given by the formula:
        \begin{equation}
          \vec r = \vec i - 2\vec N(\vec i \cdot \vec N)
        \end{equation}
\end{enumerate}

While recursive ray tracing provides a high degree of realism, especially for scenes involving glossy materials, its implementation on GPUs encounters significant challenges. GPUs are not well-suited to handle recursive operations due to their parallel processing architecture. Recursion requires a stack-based memory model, which is more naturally handled by CPUs. Moreover, recursive ray tracing is computationally intensive, especially with multiple bounces (reflections). Each additional bounce increases the complexity exponentially, making real-time rendering particularly challenging.

Nonetheless, ``recursive'' ray tracing with a very shallow depth of 2 bounces was implemented. This already brings the maximum numbers of rays that can be casted per pixel to 6.
This will serve as more of a stress test of the engine and ray-casting algorithms.

The software implementation consists of chaining the same function, copied repeatedly but with different names and setting them up to call each other in sequence.
The \texttt{ray\_trace} function can call the \texttt{ray\_trace1} function, which can call the \texttt{ray\_trace2}, all of which can call shadow ray functions.

The colour model of this for glossy materials develops on the previous one, computing the diffuse part of the colour the same way but mixing it with the reflected colour based on a reflectance coefficient $k_{r}$
The final colour returned by the function is a mix of the ambient plus diffuse lighting and the colour from the reflected ray, weighted by the reflectivity.
This mixing accounts for both direct illumination and the effects of reflections from other surfaces.

\begin{lstlisting}[language=rust,caption={Glossy materials color model}, captionpos=b]
  let N = normalize(-step * vec3<f32>(hit.mask));
  let rdir = normalize(dir - 2.0 * N * dot(dir, N));
  let rsrc = hit.p - 4e-2 * step * vec3<f32>(hit.mask);
  let rcol = ray_trace1(rsrc, rdir);
  let LN = max(0.0, s.sun_color.a * dot(-s.sun_dir, N));
  let I_d = k_d * s.sun_color.xyz * hit.color * LN;
  let I_a = k_a * AMBIENT_COLOR * hit.color;

  if I != 0.0  &&
  hdda_ray(hit.p - 4e-2 * step * vec3<f32>(hit.mask), -s.sun_dir).state == 0u {
    return mix(I_a, rcol, k_r);
  }
  return mix(I_a + I_d, rcol, k_r);
\end{lstlisting}

This concludes the methodology section.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
